### 🤔3장 질의 응답

## 1. ref를 자식컴포넌트의 props로 넘길 때 경고문이 뜨게 되는데 뜨는 이유

 ref 예약어가 존재해서, forwardRef를 사용하여 명시적으로 ref를 전달하는 것이 좋습니다. 
 forwardRef를 사용하면 컴포넌트가 부모로부터 ref를 받을 수 있게 되며, 이를 활용하여 코드를 더 명확하게 작성할 수 있습니다.
 
---

## 2. setState(state + 1)과 setState(prev => prev + 1) 차이점은?

1. **값의 의존성**: `setState(state + 1)`의 경우 현재 state 값을 기반으로 새로운 state를 설정합니다. 이는 현재 state 값에 의존성이 있으며, 이전 state 값을 명시적으로 참조하지 않습니다.
 반면에 `setState(prev => prev + 1)`의 경우 이전 state 값을 인자로 받아와서 이를 기반으로 새로운 state를 설정하므로, 이전 state 값을 명시적으로 참조합니다.
 
2. **비동기 동작**: `setState(state + 1)`은 현재 state 값을 기반으로 새로운 state를 설정하므로, 여러 번 호출될 때 예상치 못한 동작이 발생할 수 있습니다.
예를 들어, 여러 번 호출되면 모든 호출이 이전 state 값을 기반으로 하므로 원하는 대로 동작하지 않을 수 있습니다. 반면에 `setState(prev => prev + 1)`은 이전 state 값을 인자로 받아오므로, 여러 번 호출되더라도 이전 state 값을 올바르게 기반으로 하여 원하는 동작을 수행할 수 있습니다.
---

## 3. 컴포넌트를 메모이제션할 때 useMemo보다 React.memo를 사용하는게 좋은 이유는?

`useMemo` 훅은 주어진 함수를 메모이제이션하여, 의존성 배열이 변경될 때만 함수를 다시 계산하고 그 값을 기억합니다. 반면에 `React.memo`는 함수 컴포넌트의 렌더링 결과를 메모이제이션하여, props가 변경되지 않으면 이전 결과를 재사용합니다.

`React.memo`를 사용하는 것이 `useMemo`보다 더 적합한 경우는 **렌더링 결과의 메모이제이션** 때문입니다. `React.memo`는 함수 컴포넌트의 렌더링 결과를 메모이제이션하여, props가 변경되지 않으면 다시 렌더링을 수행하지 않습니다. 이는 불필요한 렌더링을 방지하고 성능을 향상시킬 수 있습니다.
